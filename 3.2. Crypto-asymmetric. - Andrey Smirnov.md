# Домашнее задание к занятию «3.2. Ассиметричные криптосистемы»/ - Андрей Смирнов.

## Задача LibreSSL & OpenSSL

### Задача

В этой задаче мы научимся шифровать данные с помощью публичного ключа и расшифровывать с помощью приватного.

Первое, с чего мы должны начать - это сгенерировать ключ. Для этого нужно выбрать алгоритм, размер ключа и passphrase (кодовую фразу).

#### Шаг 1. Создайте закрытый ключ с длиной 2048:

```shell script
openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -aes256 -out private.key
```

Где [`genpkey`](https://www.openssl.org/docs/manmaster/man1/openssl-genpkey.html) - подкоманда, отвечающая за генерацию ключей.

Введите кодовую фразу два раза (обратите внимание, символы не будут отображаться в целях безопасности).

Откройте файл `private.key` в любом текстовом редакторе (можете просмотреть в терминале с помощью команды `cat private.key`), удостоверьтесь, что он выглядит примерно так:

```text
-----BEGIN ENCRYPTED PRIVATE KEY-----
...
МНОГО БУКВ
...
-----END ENCRYPTED PRIVATE KEY-----
```

#### Шаг 2. Сгенерируйте открытый ключ на базе закрытого: 

```shell script
openssl pkey -pubout -in private.key -out public.key
```

Где [`pkey`](https://www.openssl.org/docs/man1.0.2/man1/pkey.html) - подкоманда, отвечающая за обработку ключей.

Откройте файл `public.key` (можете просмотреть в терминале с помощью команды `cat public.key`) в любом текстовом редакторе, удостоверьтесь, что он выглядит примерно так:

```text
-----BEGIN PUBLIC KEY-----
...
МНОГО БУКВ
...
-----END PUBLIC KEY-----
```

#### Шаг 3. Создайте файл message.txt со своей фамилией

#### Шаг 4. Зашифруйте сообщение с помощью публичного ключа: 

```shell script
openssl pkeyutl -encrypt -pubin -inkey public.key -in message.txt -out cypher.txt
```

Где [`pkeyutl`](https://www.openssl.org/docs/manmaster/man1/openssl-pkeyutl.html) - подкоманда, отвечающая за низкоуровневые операции с публичными ключами (включая шифрование и расшифрование).

Откройте файл `cypher.txt` в любом текстовом редакторе, удостоверьтесь, что он не читабелен.

#### Шаг 5. Убедитесь, что файл `cyper.txt` расшифровывается:

```shell script
openssl pkeyutl -decrypt -inkey private.key -in cypher.txt -out decrypted.txt
```

### Результат

В качестве результата пришлите:
1. Публичный и приватный ключ (`public.key` и `private.key`)
2. Passphrase (строкой)
3. Зашифрованный файл (`cypher.txt`)


-----


### Ответ:

Скриншот терминала:

![sshot3_2_z1-1](img/3_2_z1_1.jpg)

Результат:
1. Публичный ключ [`public.key`](assets/3_2/public.key)
1. Публичный ключ [`private.key`](assets/3_2/private.key)
1. Passphrase `netology2024`
1. Зашифрованный файл [`cypher.txt`](assets/2_3/cypher.txt)


-----

## Задача GnuPG: подпись сообщения

В этом ДЗ мы научимся подписывать и проверять подпись документов с помощью [GnuPG](https://gnupg.org) - популярной реализации [OpenPGP](https://www.ietf.org/rfc/rfc4880.txt). В частности, она используется в большом количестве Open Source проектов для подписи пакетов с ПО.
 
### Инструкция 
 
Общая логика работы с OpenPGP выглядит следующим образом:
1. Генерация хэша сообщения
2. Шифрование хэша с помощью вашего приватного ключа (подпись)
3. Отправка сообщения и подписи получателю
4. Верификация подписи и содержимого сообщения получателем (с использованием вашего публичного ключа)

Это значит, что первое, что нам нужно сделать - это сгенерировать ключевую пару (keypair*).

Примечание*: мы будем использовать и русскоязычную, и англоязычную терминологию, поскольку нам придётся работать с обеими.

Чтобы себя идентифицировать, пользователи в рамках OpenPGP создают UID (User ID):
* Имя
* Email
* Комментарий

GnuGP сохраняет всю информацию в вашем домашнем каталоге - `$HOME/.gnupg` (для Cygwin `$HOME` так же будет работать).

Справку по работе с командой можно получить следующим образом:
```shell script
gpg --help
```

#### Шаг 1. Генерация keypair

```shell script
gpg --full-generate-key
```

В диалоговом окне:
1. Выберите тип ключа: `RSA и RSA`
1. Размер ключа: `2048`
1. Срок действия ключа - `0` (не ограничен)

Далее введите:
1. Имя (ваше реальное имя)
1. Email
1. Комментарий оставьте пустым

После чего вас попросят ввести passphrase для защиты ключа.

#### Шаг 2. Просмотр ключей

```shell script
gpg --list-keys
# либо в коротком формате:
gpg -k
```

#### Шаг 3. Подпись сообщения

Создайте текстовый файл с сегодняшней датой в любом формате и сохраните его в файле `message.txt`.

Подпишите его следующей командой (подпись будет создана в виде отдельного файла):

```shell script
gpg --output message.sig --local-user coursar@localhost --detach-sign message.txt
```

Где `coursar@localhost` - это email, который вы указали на первом шаге.

Проверьте, что подпись соответствует сообщению с помощью команды:

```shell script
gpg --verify message.sig message.txt
```

#### Шаг 4. Проверка подписи (ложное сообщение)

Создайте текстовый файл `modified.txt` и измените в нём дату на вчерашнюю.

Удостоверьтесь, что проверка подписи теперь не проходит:

```shell script
gpg --verify message.sig modified.txt
```

#### Шаг 5. Экспорт публичного ключа

Для того, чтобы остальные пользователи могли проверять подпись ваших сообщений, вы должны им предоставить ваш публичный ключ.

Для этого нужно его экспортировать с помощью следующей команды:

```shell script
gpg --output public.gpg --armor --export coursar@localhost
```

Где `coursar@localhost` - это email, который вы указали на первом шаге.

По умолчанию, ключ экспортируется в бинарном формате. Опция `--armor` позволяет экспортировать его в текстовом виде.

### Результат

В качестве результата пришлите:
1. Публичный ключ (с шага 5)
1. Файл сообщения и подпись к нему (с шага 3)


-----


### Ответ:


Генерация keypair:

![sshot3_2_z2-1](img/3_2_z2_1.jpg)

Просмотр ключей и работа с подписью (пункты 2-5):

![sshot3_2_z2-2](img/3_2_z2_2.jpg)


-----



## Задача GnuPG: decrypt*

**Важно**: это не обязательная задача. Её (не)выполнение не влияет на получение зачёта по ДЗ.

В этом ДЗ мы научимся расшифровывать и проверять подпись сообщений, зашифрованных с помощью GnuPG.

### Замечание

В отечественной терминологии различают термин расшифрование и дешифрование. Под дешифрованием фактически понимается "взлом" шифра.

В западной терминологии decrypt означает именно расшифрование.

### Инструкция

Общая логика работы с OpenPGP выглядит следующим образом: с помощью публичного ключа получателя шифруется сообщение (расшифровать его можно только с помощью приватного ключа, который должен быть у вас). Про подпись вы уже знаете из предыдущего ДЗ.

Список ключей:
1. Приватный ключ получателя [`student.key`](assets/student.key)
1. Публичный ключ отправителя [`netology.gpg`](assets/netology.gpg).

Приватный ключ нужен для того, чтобы вы могли расшифровать сообщение.

Сейчас мы эмулируем ситуацию, что приватный ключ каким-то образом попал к вам (а ещё, вот удача, вам стал известен passphrase), поэтому теперь вы можете попытаться расшифровать сообщение.

<details>
<summary>Когда такое может случиться?</summary>

Случается это сплошь и рядом:
1. Потерянная флешка, на которой хранился "бэкап" и аккуратно в текстовом файлике passphrase "чтобы не забыть"
1. Ноутбук, отданный в ремонт (с аналогичным первому пункту хранению данных)
1. "Случайно" выложенный разработчиком в системы контроля версий (вроде GitHub) приватный ключ и passphrase к нему в исходных кодах приложения или конфигурационных файлах
1. То же, что и предыдущий пункт, но бэкап пользовательских данных (где-нибудь в облаке)
1. И т.д.

По поводу п.3 можете почитать [замечательное исследование](https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_04B-3_Meli_paper.pdf).
</details>

**Важно**: никогда не выкладывайте приватные и passphrase к ним в онлайн. Это неправильно и ни при каких условиях так делать не стоит.

Скачайте их и сохраните его в ваш каталог `$HOME` (далее выполняйте все команды там).

#### Шаг 1. Импортируйте ключи

Для этого выполните следующую команду:

```shell script
gpg --import netology.gpg
gpg --import student.key
```

<details>
<summary>Passphrase для student.key 😈</summary>

Passphrase: `student`.

<details>
<summary>Неправильная passphrase 😈?</summary>

Такое бывает. Достаточно часто для "стойкости" пароли набирают на другой раскладке (или просто забывают переключить раскладку). Попробуйте `student` в русской раскладке.

Если уж совсем не получилось, то держите скрипт, который всё сделает за вас:

<details>
<summary>Импорт ключа с вводом passphrase</summary>

```shell script
echo ыегвуте | gpg --batch --yes --import student.key
```

</details>

</details>
</details>

#### Шаг 2. Убедитесь, что ключи импортированы

```shell script
gpg --list-keys
```

#### Шаг 3. Расшифруйте сообщение и проверьте подпись

```shell script
gpg --decrypt message.enc
```

Где [`message.enc`](assets/message.enc) - это зашифрованный файл, который вам прислал владелец [`netology.gpg`](assets/netology.gpg).

### Результат

В качестве результата пришлите:
1. Содержимое зашифрованного сообщения (текст)
1. Результат проверки подписи (валидна или нет)



-----


### Ответ:




-----


## Распространение дистрибутивов*

**Важно**: это не ДЗ, присылать его на проверку не нужно. Это доп.задание, предназначенное для ознакомления.

То, как мы распространяли публичные ключи - используется редко. В рамках OpenPGP существуют специальные сервера, предназначенные для распространения публичных ключей, например, https://keyserver.ubuntu.com/.

Соответственно, предлагаем вам ознакомиться с [инструкцией](https://ubuntu.com/tutorials/how-to-verify-ubuntu#1-overview), которую предлагает Ubuntu, для проверки скачанных дистрибутивов.

Для этого вам понадобятся GnuPG (который вы установили) и инструмент для подсчёта КС SHA256 (команда `sha256sum`). Если вы сделали предыдущие ДЗ, то в Windows они у вас уже установлены (Cygwin), в Linux тоже, в Mac потребуется выполнить команду `brew install coreutils`.

Далее необходимо пошагово пройти инструкцию.
